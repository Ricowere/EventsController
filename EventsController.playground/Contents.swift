//: Typesafe Notifications - A lean approach
import UIKit

//: EventIdentifier - Typealias to give more context.
typealias EventIdentifier = String


//: Event - Declaration that represents an event that could happen in the system.
protocol Event: NotificationAdapter {
	
	/// Every event has to be identified univocally.
	static var identifier: EventIdentifier { get }
}


//: NotificationAdapter - Declaration that represents the minimum contract to be implemented for adapting a Notification.
protocol NotificationAdapter {
	init(notification: Notification)
	
	var notification: Notification { get }
	
	var params: [AnyHashable : Any]? { get }
}

//: Default Event extension - An event could perfectly works with this minimum information provided.
extension Event {
	static var identifier: EventIdentifier {
		return String(describing: Self.self)
	}
	
	var params: [AnyHashable : Any]? {
		return nil
	}
	
	var notification: Notification {
		return Notification(name: Notification.Name(rawValue: Self.identifier),
		                    object: nil,
		                    userInfo: params)
	}
}


//: Observer - Object to be holded to listen a notification from the event bus when needed. This object automatically will unregister the inner token that was previously registered. This object cannot be automatically created. It'll returned by the listen method.
final class Observer {
	fileprivate weak var eventsController: EventsController?
	fileprivate let token: AnyObject
	
	fileprivate init(eventsController: EventsController,
	                 token: AnyObject) {
		self.eventsController = eventsController
		self.token = token
	}
	
	deinit { eventsController?.stop(listening: [self]) }
}

//: EventsController - It will be the responsible for publishing/listening the events happened.
final class EventsController {
	fileprivate let eventsBus: NotificationCenter = NotificationCenter()
	fileprivate let eventsQueue: OperationQueue
	fileprivate lazy var tokens = [AnyObject]()
	
	init() {
		eventsQueue = OperationQueue()
		eventsQueue.name = "com.eventsController.eventsQueue"
	}
	
	deinit { stopListening(tokens) }
	
	/**
	Publish the desired event to get propagated through the listeners.
	
	- parameter event: Provide the event to be propagated.
	*/
	func publish(by event: Event) {
		eventsBus.post(event.notification as Notification)
	}
	
	/**
	Register an listener for the desired event.
	
	- parameter event:            Event to be listened
	- parameter once:             Pass true if you want to listen the event once
	- parameter onEventPublished: Handler to be execute when the event occur
	
	- returns: Observer to be holded by the caller, once this observer is released, is automatically unregistered.
	*/
	func listen<Ev: Event>(for event: Ev.Type, once: Bool = false, onEventPublished: @escaping (Ev) -> ()) -> Observer {
		weak var token: NSObjectProtocol?
		
		token =
			eventsBus.addObserver(forName: NSNotification.Name(rawValue: event.identifier),
			                      object: nil,
			                      queue: eventsQueue) { [weak self] notification in
									
									if (once) { self?.stopListening([token!]) }
									onEventPublished(event.init(notification: notification))
		}
		
		tokens.append(token!)
		
		return Observer(eventsController: self, token: token!)
	}
	
	fileprivate func stop(listening observers: [Observer]) {
		stopListening(observers.map({ return $0.token }))
	}
	
	/**
	Stop listened the events generated by the events bus.
	
	- parameter tokens: Provide the tokens that was previously registered by the events bus to be unregistered.
	*/
	func stopListening(_ tokens: [AnyObject]) {
		/**
		*  Firstly, we need to make sure we'll unregister tokens that was
		*  previously registered and haven't been unregistered before.
		*/
		let validTokens =
			tokens.filter { token in
				return self.tokens.contains { return $0.isEqual(token) }
		}
		
		validTokens.forEach { toRemoveToken in
			if let index = self.tokens.index(where: { $0.isEqual(toRemoveToken)}) {
				self.tokens.remove(at: index)
			}
			eventsBus.removeObserver(toRemoveToken)
		}
	}
}

//: Example of use
struct ExampleEvent: Event {
	fileprivate static let relevantValueKey = "relevantValueKey"
	
	let relevantValue: String
}

extension ExampleEvent {
	var params: [AnyHashable : Any]? {
		return [ExampleEvent.relevantValueKey : relevantValue]
	}
	
	init(notification: Notification) {
		guard let userInfo = notification.userInfo,
			let value = userInfo[ExampleEvent.relevantValueKey] as? String else {
				fatalError("Inconsistent state. Fatal error. Review inmediately")
		}
		relevantValue = value
	}
}

/// EventsController
let eventsController = EventsController()


/// Listening.
let observer =
eventsController.listen(for: ExampleEvent.self) { event in
	print("Event received")
}

/// Publishing.
eventsController.publish(by: ExampleEvent(relevantValue: "Relevant"))
