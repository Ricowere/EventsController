
import Foundation

final class EventsController {
    fileprivate let eventsBus: NotificationCenter = NotificationCenter()
    fileprivate let eventsQueue: OperationQueue
    fileprivate lazy var tokens = [AnyObject]()
	
    init() {
        eventsQueue = OperationQueue()
        eventsQueue.name = "com.eventsController.eventsQueue"
    }
    
    deinit {
        stopListening(tokens)
    }
    
    /**
     Publish the desired event to get propagated through the listeners.
     
     - parameter event: Provide the event to be propagated.
     */
    func publish(by event: Event) {
        eventsBus.post(event.notification as Notification)
    }
	
	/**
	Register an listener for the desired event.
	
	- parameter event:            Event to be listened
	- parameter once:             Pass true if you want to listen the event once
	- parameter onEventPublished: Handler to be execute when the event occur
	
	- returns: Observer to be holded by the caller, once this observer is released, is automatically unregistered.
	*/
	func listen<Ev: Event>(for event: Ev.Type, once: Bool = false, onEventPublished: @escaping (Ev) -> ()) -> Observer {
		weak var token: NSObjectProtocol?
		
		token =
			eventsBus.addObserver(forName: NSNotification.Name(rawValue: event.identifier),
			                      object: nil,
			                      queue: eventsQueue) { [weak self] notification in
									
									if (once) { self?.stopListening([token!]) }
									onEventPublished(event.init(notification: notification))
		}
		
		tokens.append(token!)
		
		return Observer(eventsController: self, token: token!)
	}
	
	fileprivate func stop(listening observers: [Observer]) {
		stopListening(observers.map({ return $0.token }))
	}
	
    /**
     Stop listened the events generated by the events bus.
     
     - parameter tokens: Provide the tokens that was previously registered by the events bus to be unregistered.
     */
	func stopListening(for tokens: [AnyObject]) {
        /**
         *  Firstly, we need to make sure we'll unregister tokens that was
         *  previously registered and haven't been unregistered before.
         */
        let validTokens =
        tokens.filter { token in
            return self.tokens.contains { return $0.isEqual(token) }
        }
        
        validTokens.forEach { toRemoveToken in
            if let index = self.tokens.index(where: { $0.isEqual(toRemoveToken)}) {
                self.tokens.remove(at: index)
            }
            eventsBus.removeObserver(toRemoveToken)
        }
    }
}
